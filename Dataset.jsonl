{\rtf1\ansi\ansicpg1252\cocoartf2708
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red174\green176\blue183;\red23\green23\blue26;\red185\green101\blue173;
\red89\green158\blue96;\red195\green123\blue90;}
{\*\expandedcolortbl;;\csgenericrgb\c68235\c69020\c71765;\csgenericrgb\c9020\c9020\c10196;\csgenericrgb\c72549\c39608\c67843;
\csgenericrgb\c34902\c61961\c37647;\csgenericrgb\c76471\c48235\c35294;}
\margl1440\margr1440\vieww24460\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \cb3 \{\cf4 "messages"\cf2 : [\{\cf4 "role"\cf2 : \cf5 "system"\cf2 , \cf4 "content"\cf2 : \cf5 "Erin is a stock trading expert and good at coding."\cf2 \},\
  \{\cf4 "role"\cf2 : \cf5 "user"\cf2 , \cf4 "content"\cf2 : \cf5 "Short moving averge is 10, long moving average is 21. when the short moving average is larger than long moving average, we long and hold, when the short moving average is smaller than long moving average, we clear positions. What ia the python code to do backtest for this strategy."\cf2 \},\
  \{\cf4 "role"\cf2 : \cf5 "assistant"\cf2 , \cf4 "content"\cf2 : \cf5 "import matplotlib.pyplot as plt\cf6 \\n\cf5 import numpy as np\cf6 \\n\cf5 import pandas as pd\cf6 \\n\cf5 import yfinance as yf\cf6 \\n\\n\cf5 # simple moving average\cf6 \\n\cf5 def macd(signals):\cf6 \\n\cf5     signals['ma1'] = signals['Close'].rolling(window=ma1, min_periods=1, center=False).mean()\cf6 \\n\cf5     signals['ma2'] = signals['Close'].rolling(window=ma2, min_periods=1, center=False).mean()\cf6 \\n\\n\cf5     return signals\cf6 \\n\\n\cf5 def signal_generation(df, method):\cf6 \\n\cf5     signals = method(df)\cf6 \\n\cf5     signals['positions'] = 0\cf6 \\n\\n\cf5     # positions becomes and stays one once the short moving average is above long moving average\cf6 \\n\cf5     signals['positions'][ma1:] = np.where(signals['ma1'][ma1:] >= signals['ma2'][ma1:], 1, 0)\cf6 \\n\\n\cf5     # as positions only imply the holding\cf6 \\n\cf5     # we take the difference to generate real trade signal\cf6 \\n\cf5     signals['signals'] = signals['positions'].diff()\cf6 \\n\\n\cf5     # oscillator is the difference between two moving average\cf6 \\n\cf5     # when it is positive, we long, vice versa\cf6 \\n\cf5     signals['oscillator'] = signals['ma1'] - signals['ma2']\cf6 \\n\\n\cf5     return signals\cf6 \\n\\n\\n\cf5 # plotting the backtesting result\cf6 \\n\cf5 def plot(new, ticker):\cf6 \\n\cf5     fig = plt.figure()\cf6 \\n\cf5     ax = fig.add_subplot(111)\cf6 \\n\\n\cf5     new['Close'].plot(label=ticker)\cf6 \\n\cf5     ax.plot(new.loc[new['signals'] == 1].index, new['Close'][new['signals'] == 1], label='LONG', lw=0, marker='^',\cf6 \\n\cf5             c='g')\cf6 \\n\cf5     ax.plot(new.loc[new['signals'] == -1].index, new['Close'][new['signals'] == -1], label='SHORT', lw=0, marker='v',\cf6 \\n\cf5             c='r')\cf6 \\n\\n\cf5     plt.legend(loc='best')\cf6 \\n\cf5     plt.grid(True)\cf6 \\n\cf5     plt.title('Positions')\cf6 \\n\\n\cf5     plt.show()\cf6 \\n\\n\cf5     fig = plt.figure()\cf6 \\n\cf5     cx = fig.add_subplot(211)\cf6 \\n\\n\cf5     new['oscillator'].plot(kind='bar', color='r')\cf6 \\n\\n\cf5     plt.legend(loc='best')\cf6 \\n\cf5     plt.grid(True)\cf6 \\n\cf5     plt.xticks([])\cf6 \\n\cf5     plt.xlabel('')\cf6 \\n\cf5     plt.title('MACD Oscillator')\cf6 \\n\\n\cf5     bx = fig.add_subplot(212)\cf6 \\n\\n\cf5     new['ma1'].plot(label='ma1')\cf6 \\n\cf5     new['ma2'].plot(label='ma2', linestyle=':')\cf6 \\n\\n\cf5     plt.legend(loc='best')\cf6 \\n\cf5     plt.grid(True)\cf6 \\n\cf5     plt.show()\cf6 \\n\\n\cf5 def main():\cf6 \\n\\n\cf5     global ma1, ma2, stdate, eddate, ticker, slicer\cf6 \\n\\n\cf5     ma1 = 10\cf6 \\n\cf5     ma2 = 21\cf6 \\n\cf5     stdate = input('start date in format yyyy-mm-dd:')\cf6 \\n\cf5     eddate = input('end date in format yyyy-mm-dd:')\cf6 \\n\cf5     ticker = input('ticker:')\cf6 \\n\\n\cf5     slicer = int(input('slicing:'))\cf6 \\n\\n\cf5     # downloading data\cf6 \\n\cf5     df = yf.download(ticker, start=stdate, end=eddate)\cf6 \\n\\n\cf5     new = signal_generation(df, macd)\cf6 \\n\cf5     new = new[slicer:]\cf6 \\n\cf5     plot(new, ticker)\cf6 \\n\\n\cf5 if __name__ == '__main__':\cf6 \\n\cf5     main()"\cf2 \}]\}\
\
}